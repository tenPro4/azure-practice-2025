trigger:
- main

pool:
  name: 'binet-window-agent'

variables:
  solution: '**/*.sln'
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'
  # 设置你的 Azure Artifacts feed 名称
  artifactFeed: 'binet25'
  # 定义需要打包的项目模式（支持通配符）
  packableProjects: |
    **/*.Entities.csproj
    **/*.Services.csproj

steps:
- task: DotNetCoreCLI@2
  displayName: 'Restore packages'
  inputs:
    command: 'restore'
    projects: '**/*.csproj'

- task: DotNetCoreCLI@2
  displayName: 'Build'
  inputs:
    command: 'build'
    projects: '**/*.csproj'
    arguments: '--configuration $(buildConfiguration) --no-restore'

# 运行单元测试
- task: DotNetCoreCLI@2
  displayName: 'Run Unit Tests'
  inputs:
    command: 'test'
    projects: '**/*.UnitTest.csproj'
    arguments: '--configuration $(buildConfiguration) --no-build'
    publishTestResults: true

# 智能检查并打包所有可打包项目
- task: PowerShell@2
  displayName: 'Check and Pack NuGet Packages'
  inputs:
    targetType: 'inline'
    script: |
      # 定义要打包的项目模式
      $projectPatterns = @(
        "**/*.Entities.csproj",
        "**/*.Services.csproj"
      )
      
      $feedUrl = "https://pkgs.dev.azure.com/binet25/_packaging/$(artifactFeed)/nuget/v3/index.json"
      $outputDir = "$(Build.ArtifactStagingDirectory)/packages"
      $hasNewPackages = $false
      
      # 创建输出目录
      if (-not (Test-Path $outputDir)) {
        New-Item -ItemType Directory -Path $outputDir | Out-Null
      }
      
      Write-Host "=== Scanning for packable projects ==="
      
      # 查找所有匹配的项目
      $allProjects = @()
      foreach ($pattern in $projectPatterns) {
        $foundProjects = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter ($pattern -replace '\*\*/', '') -Recurse -ErrorAction SilentlyContinue
        $allProjects += $foundProjects
      }
      
      if ($allProjects.Count -eq 0) {
        Write-Host "##[warning]No packable projects found matching the patterns"
        Write-Host "##vso[task.setvariable variable=HasNewPackages]false"
        exit 0
      }
      
      Write-Host "Found $($allProjects.Count) project(s) to process"
      
      # 处理每个项目
      foreach ($project in $allProjects) {
        Write-Host ""
        Write-Host "=== Processing: $($project.Name) ==="
        
        # 读取项目版本
        [xml]$csproj = Get-Content $project.FullName
        $currentVersion = $csproj.Project.PropertyGroup.Version
        
        if ([string]::IsNullOrEmpty($currentVersion)) {
          $currentVersion = "1.0.0"
          Write-Host "##[warning]No version specified, using default: $currentVersion"
        }
        
        # 提取包名（移除 .csproj 扩展名）
        $packageName = $project.BaseName
        Write-Host "Package: $packageName"
        Write-Host "Version: $currentVersion"
        
        # 检查版本是否已存在
        Write-Host "Checking if version exists in feed..."
        $versionExists = $false
        
        try {
          # 使用 dotnet nuget 命令搜索包
          $searchCmd = "dotnet nuget list source $(artifactFeed) $packageName --format json"
          $searchResult = Invoke-Expression $searchCmd 2>&1 | Out-String
          
          # 检查是否包含当前版本
          if ($searchResult -match "$packageName\s+$currentVersion") {
            $versionExists = $true
          }
        } catch {
          Write-Host "##[warning]Could not search feed (this is OK for first-time packages)"
        }
        
        if ($versionExists) {
          Write-Host "##[warning]Version $currentVersion already exists in feed - SKIPPING"
        } else {
          Write-Host "##[section]Version $currentVersion is NEW - PACKING"
          
          # 打包项目
          $packResult = dotnet pack $project.FullName `
            --configuration $(buildConfiguration) `
            --no-build `
            --output $outputDir `
            /p:Version=$currentVersion
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully packed $packageName $currentVersion"
            $hasNewPackages = $true
          } else {
            Write-Host "##[error]Failed to pack $packageName"
          }
        }
      }
      
      # 设置变量供后续步骤使用
      Write-Host ""
      Write-Host "=== Summary ==="
      if ($hasNewPackages) {
        Write-Host "##[section]New packages are ready to push"
        Write-Host "##vso[task.setvariable variable=HasNewPackages]true"
      } else {
        Write-Host "##[warning]No new packages to push"
        Write-Host "##vso[task.setvariable variable=HasNewPackages]false"
      }

# 推送 NuGet 包到 Azure Artifacts
- task: NuGetCommand@2
  displayName: 'Push NuGet Packages to Azure Artifacts'
  condition: eq(variables['HasNewPackages'], 'true')
  inputs:
    command: 'push'
    packagesToPush: '$(Build.ArtifactStagingDirectory)/packages/*.nupkg'
    nuGetFeedType: 'internal'
    publishVstsFeed: '$(artifactFeed)'
    allowPackageConflicts: true

- task: DotNetCoreCLI@2
  displayName: 'Publish'
  inputs:
    command: 'publish'
    projects: '**/*.csproj'
    arguments: '--configuration $(buildConfiguration) --no-build -o $(Build.ArtifactStagingDirectory)/publish'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Build Artifacts'
  inputs:
    pathToPublish: '$(Build.ArtifactStagingDirectory)/publish'
    artifactName: 'drop'

- task: PublishBuildArtifacts@1
  displayName: 'Publish NuGet Packages'
  condition: eq(variables['HasNewPackages'], 'true')
  inputs:
    pathToPublish: '$(Build.ArtifactStagingDirectory)/packages'
    artifactName: 'nuget-packages'

- task: PowerShell@2
  displayName: 'Extract Artifacts and Deploy to IIS'
  inputs:
    targetType: 'inline'
    script: |
      $zipFilePath = "$(Pipeline.Workspace)/drop/SPP.zip"  # Path to the zipped artifact
      $extractPath = "$(Build.ArtifactStagingDirectory)/publish"  # Path to extract
      $destPath = "C:\inetpub\wwwroot\project1"  # IIS directory

      # Check if ZIP file exists
      if (-Not (Test-Path $zipFilePath)) {
          Write-Host "##[error]The ZIP file does not exist at $zipFilePath"
          exit 1
      }

      # Create extraction directory if it doesn't exist
      if (-Not (Test-Path $extractPath)) {
          New-Item -ItemType Directory -Path $extractPath -Force
      }

      # Extract the ZIP file
      Write-Host "Extracting $zipFilePath to $extractPath"
      Expand-Archive -Path $zipFilePath -DestinationPath $extractPath -Force

      # Ensure destination directory exists
      if (-Not (Test-Path $destPath)) {
          New-Item -ItemType Directory -Path $destPath -Force
      }

      # Copy files from the extraction directory to the IIS directory
      Copy-Item -Path "$extractPath/*" -Destination $destPath -Recurse -Force
      Write-Host "Successfully deployed to $destPath"