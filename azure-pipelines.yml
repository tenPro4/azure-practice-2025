trigger:
- main

pool:
  name: 'binet-window-agent'

variables:
  solution: '**/*.sln'
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'
  # 设置你的 Azure Artifacts feed 名称
  artifactFeed: 'binet25'
  # 定义需要打包的项目模式（支持通配符）
  packableProjects: |
    **/*.Entities.csproj
    **/*.Services.csproj

steps:
- task: DotNetCoreCLI@2
  displayName: 'Restore packages'
  inputs:
    command: 'restore'
    projects: '**/*.csproj'

- task: DotNetCoreCLI@2
  displayName: 'Build'
  inputs:
    command: 'build'
    projects: '**/*.csproj'
    arguments: '--configuration $(buildConfiguration) --no-restore'

# 运行单元测试
- task: DotNetCoreCLI@2
  displayName: 'Run Unit Tests'
  inputs:
    command: 'test'
    projects: '**/*.UnitTest.csproj'
    arguments: '--configuration $(buildConfiguration) --no-build'
    publishTestResults: true

# 智能检查并打包所有可打包项目
- task: PowerShell@2
  displayName: 'Check and Pack NuGet Packages'
  inputs:
    targetType: 'inline'
    script: |
      # 定义要打包的项目模式
      $projectPatterns = @(
        "**/*.Entities.csproj",
        "**/*.Services.csproj"
      )
      
      $feedUrl = "https://pkgs.dev.azure.com/binet25/_packaging/$(artifactFeed)/nuget/v3/index.json"
      $outputDir = "$(Build.ArtifactStagingDirectory)/packages"
      $hasNewPackages = $false
      
      # 创建输出目录
      if (-not (Test-Path $outputDir)) {
        New-Item -ItemType Directory -Path $outputDir | Out-Null
      }
      
      Write-Host "=== Scanning for packable projects ==="
      
      # 查找所有匹配的项目
      $allProjects = @()
      foreach ($pattern in $projectPatterns) {
        $foundProjects = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter ($pattern -replace '\*\*/', '') -Recurse -ErrorAction SilentlyContinue
        $allProjects += $foundProjects
      }
      
      if ($allProjects.Count -eq 0) {
        Write-Host "##[warning]No packable projects found matching the patterns"
        Write-Host "##vso[task.setvariable variable=HasNewPackages]false"
        exit 0
      }
      
      Write-Host "Found $($allProjects.Count) project(s) to process"
      
      # 处理每个项目
      foreach ($project in $allProjects) {
        Write-Host ""
        Write-Host "=== Processing: $($project.Name) ==="
        
        # 读取项目版本
        [xml]$csproj = Get-Content $project.FullName
        $currentVersion = $csproj.Project.PropertyGroup.Version
        
        if ([string]::IsNullOrEmpty($currentVersion)) {
          $currentVersion = "1.0.0"
          Write-Host "##[warning]No version specified, using default: $currentVersion"
        }
        
        # 提取包名（移除 .csproj 扩展名）
        $packageName = $project.BaseName
        Write-Host "Package: $packageName"
        Write-Host "Version: $currentVersion"
        
        # 检查版本是否已存在
        Write-Host "Checking if version exists in feed..."
        $versionExists = $false
        
        try {
          # 使用 dotnet nuget 命令搜索包
          $searchCmd = "dotnet nuget list source $(artifactFeed) $packageName --format json"
          $searchResult = Invoke-Expression $searchCmd 2>&1 | Out-String
          
          # 检查是否包含当前版本
          if ($searchResult -match "$packageName\s+$currentVersion") {
            $versionExists = $true
          }
        } catch {
          Write-Host "##[warning]Could not search feed (this is OK for first-time packages)"
        }
        
        if ($versionExists) {
          Write-Host "##[warning]Version $currentVersion already exists in feed - SKIPPING"
        } else {
          Write-Host "##[section]Version $currentVersion is NEW - PACKING"
          
          # 打包项目
          $packResult = dotnet pack $project.FullName `
            --configuration $(buildConfiguration) `
            --no-build `
            --output $outputDir `
            /p:Version=$currentVersion
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "✓ Successfully packed $packageName $currentVersion"
            $hasNewPackages = $true
          } else {
            Write-Host "##[error]Failed to pack $packageName"
          }
        }
      }
      
      # 设置变量供后续步骤使用
      Write-Host ""
      Write-Host "=== Summary ==="
      if ($hasNewPackages) {
        Write-Host "##[section]New packages are ready to push"
        Write-Host "##vso[task.setvariable variable=HasNewPackages]true"
      } else {
        Write-Host "##[warning]No new packages to push"
        Write-Host "##vso[task.setvariable variable=HasNewPackages]false"
      }

# 推送 NuGet 包到 Azure Artifacts
- task: NuGetCommand@2
  displayName: 'Push NuGet Packages to Azure Artifacts'
  condition: eq(variables['HasNewPackages'], 'true')
  inputs:
    command: 'push'
    packagesToPush: '$(Build.ArtifactStagingDirectory)/packages/*.nupkg'
    nuGetFeedType: 'internal'
    publishVstsFeed: '$(artifactFeed)'
    allowPackageConflicts: true

- task: DotNetCoreCLI@2
  displayName: 'Publish API Project'
  inputs:
    command: 'publish'
    projects: '**/*.API.csproj'
    arguments: '--configuration $(buildConfiguration) --no-build -o $(Build.ArtifactStagingDirectory)/publish'
    publishWebProjects: false
    zipAfterPublish: false

# 打包发布文件用于部署
- task: ArchiveFiles@2
  displayName: 'Archive for Deployment'
  inputs:
    rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/publish'
    includeRootFolder: false
    archiveType: 'zip'
    archiveFile: '$(Build.ArtifactStagingDirectory)/package.zip'
    replaceExistingArchive: true

# 发布 NuGet 包到 Artifacts（仅在有新包时）
- task: PublishBuildArtifacts@1
  displayName: 'Publish NuGet Packages Artifact'
  condition: eq(variables['HasNewPackages'], 'true')
  inputs:
    pathToPublish: '$(Build.ArtifactStagingDirectory)/packages'
    artifactName: 'nuget-packages'

# 部署到 IIS
- task: PowerShell@2
  displayName: 'Deploy to IIS'
  inputs:
    targetType: 'inline'
    script: |
      $zipFile = "$(Build.ArtifactStagingDirectory)/package.zip"
      $iisPath = "C:\inetpub\wwwroot\project1"
      $tempExtractPath = "$(Build.ArtifactStagingDirectory)/extracted"
      
      Write-Host "=== Starting IIS Deployment ==="
      Write-Host "Source: $zipFile"
      Write-Host "Target: $iisPath"
      
      # 创建临时解压目录
      if (Test-Path $tempExtractPath) {
        Remove-Item -Path $tempExtractPath -Recurse -Force
      }
      New-Item -ItemType Directory -Path $tempExtractPath | Out-Null
      
      # 解压文件
      Write-Host "Extracting files..."
      Expand-Archive -Path $zipFile -DestinationPath $tempExtractPath -Force
      
      # 检查解压后的文件结构
      Write-Host "Checking extracted files..."
      $extractedItems = Get-ChildItem -Path $tempExtractPath
      Write-Host "Extracted items count: $($extractedItems.Count)"
      foreach ($item in $extractedItems) {
        $itemType = if ($item.PSIsContainer) { 'Directory' } else { 'File' }
        Write-Host "  - $($item.Name) [$itemType]"
      }
      
      # 如果只有一个 zip 文件，可能是嵌套打包，需要再次解压
      if ($extractedItems.Count -eq 1 -and $extractedItems[0].Extension -eq '.zip') {
        Write-Host "##[warning]Found nested zip file, extracting again..."
        $nestedZip = $extractedItems[0].FullName
        $tempExtractPath2 = "$tempExtractPath\extracted"
        Expand-Archive -Path $nestedZip -DestinationPath $tempExtractPath2 -Force
        Remove-Item -Path $nestedZip -Force
        $tempExtractPath = $tempExtractPath2
        Write-Host "Nested extraction complete"
      }
      
      # 如果只有一个文件夹，进入该文件夹进行复制（避免多一层目录）
      $extractedItems = Get-ChildItem -Path $tempExtractPath
      if ($extractedItems.Count -eq 1 -and $extractedItems[0].PSIsContainer) {
        Write-Host "##[warning]Found single folder: $($extractedItems[0].Name), copying from inside it..."
        $tempExtractPath = $extractedItems[0].FullName
        Write-Host "New source path: $tempExtractPath"
      }
      
      # 确保目标目录存在
      if (-not (Test-Path $iisPath)) {
        Write-Host "Creating target directory: $iisPath"
        New-Item -ItemType Directory -Path $iisPath -Force | Out-Null
      }
      
      # 停止应用池（可选，取决于你的应用池名称）
      try {
        $appPoolName = "project1"  # 根据实际情况修改应用池名称
        Write-Host "Stopping application pool: $appPoolName"
        Stop-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue
        Start-Sleep -Seconds 2
      } catch {
        Write-Host "##[warning]Could not stop application pool (it may not exist or already stopped)"
      }
      
      # 显示最终将要复制的文件
      Write-Host "Files to be deployed:"
      $filesToDeploy = Get-ChildItem -Path $tempExtractPath | Select-Object -First 10
      foreach ($file in $filesToDeploy) {
        $fileType = if ($file.PSIsContainer) { 'Directory' } else { 'File' }
        Write-Host "  - $($file.Name) [$fileType]"
      }
      if ((Get-ChildItem -Path $tempExtractPath).Count -gt 10) {
        Write-Host "  ... and more"
      }
      
      # 复制文件到 IIS 目录（覆盖现有文件）
      Write-Host "Copying files to IIS directory..."
      Copy-Item -Path "$tempExtractPath\*" -Destination $iisPath -Recurse -Force
      
      Write-Host "✓ Files deployed successfully"
      
      # 启动应用池
      try {
        Write-Host "Starting application pool: $appPoolName"
        Start-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue
        Write-Host "✓ Application pool started"
      } catch {
        Write-Host "##[warning]Could not start application pool"
      }
      
      # 清理临时文件
      Write-Host "Cleaning up temporary files..."
      Remove-Item -Path $tempExtractPath -Recurse -Force
      
      Write-Host "=== Deployment Complete ==="