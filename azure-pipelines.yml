trigger:
- main
- develop

pool:
  name: 'binet-window-agent'

variables:
  solution: '**/*.sln'
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'
  artifactFeed: 'binet25'
  packableProjects: |
    **/*.Entities.csproj
    **/*.Services.csproj

stages:
# ============================================
# Stage 1: 构建
# ============================================
- stage: Build
  displayName: 'Build Solution'
  jobs:
  - job: BuildJob
    displayName: 'Build Projects'
    steps:
    - task: DotNetCoreCLI@2
      displayName: 'Restore packages'
      inputs:
        command: 'restore'
        projects: '**/*.csproj'

    - task: DotNetCoreCLI@2
      displayName: 'Build'
      inputs:
        command: 'build'
        projects: '**/*.csproj'
        arguments: '--configuration $(buildConfiguration) --no-restore'

    - task: DotNetCoreCLI@2
      displayName: 'Publish API Project'
      inputs:
        command: 'publish'
        projects: '**/*.API.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build -o $(Build.ArtifactStagingDirectory)/publish'
        publishWebProjects: false
        zipAfterPublish: false

    - task: ArchiveFiles@2
      displayName: 'Archive for Deployment'
      inputs:
        rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/publish'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/package.zip'
        replaceExistingArchive: true

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Deployment Package'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/package.zip'
        artifactName: 'deployment-package'

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Build Output for Testing'
      inputs:
        targetPath: '$(Build.SourcesDirectory)'
        artifactName: 'build-output'

# ============================================
# Stage 2: 测试
# ============================================
- stage: Test
  displayName: 'Run Tests'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: UnitTest
    displayName: 'Run Unit Tests'
    steps:
    - download: current
      artifact: build-output
      displayName: 'Download Build Output'

    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: 'test'
        projects: '$(Pipeline.Workspace)/build-output/**/*.UnitTest.csproj'
        arguments: '--configuration $(buildConfiguration) --no-build --logger trx --collect:"XPlat Code Coverage"'
        publishTestResults: true

    - task: PublishCodeCoverageResults@2
      displayName: 'Publish Code Coverage'
      condition: succeededOrFailed()
      inputs:
        summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'
        codeCoverageTool: 'Cobertura'

# ============================================
# Stage 3: NuGet 打包和发布
# ============================================
- stage: Package
  displayName: 'Package and Push NuGet'
  dependsOn: 
  - Build
  - Test
  condition: succeeded()
  jobs:
  - job: NuGetPackage
    displayName: 'Create and Push NuGet Packages'
    steps:
    - task: DotNetCoreCLI@2
      displayName: 'Restore packages'
      inputs:
        command: 'restore'
        projects: '**/*.csproj'

    - task: DotNetCoreCLI@2
      displayName: 'Build for Packaging'
      inputs:
        command: 'build'
        projects: '**/*.csproj'
        arguments: '--configuration $(buildConfiguration) --no-restore'

    - task: PowerShell@2
      displayName: 'Check and Pack NuGet Packages'
      inputs:
        targetType: 'inline'
        script: |
          # 定义要打包的项目模式
          $projectPatterns = "$(packableProjects)" -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne "" }
          
          $feedUrl = "https://pkgs.dev.azure.com/binet25/_packaging/$(artifactFeed)/nuget/v3/index.json"
          $outputDir = "$(Build.ArtifactStagingDirectory)/packages"
          $hasNewPackages = $false
          
          if (-not (Test-Path $outputDir)) {
            New-Item -ItemType Directory -Path $outputDir | Out-Null
          }
          
          Write-Host "=== Scanning for packable projects ==="
          
          $allProjects = @()
          foreach ($pattern in $projectPatterns) {
            $foundProjects = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter ($pattern -replace '\*\*/', '') -Recurse -ErrorAction SilentlyContinue
            $allProjects += $foundProjects
          }
          
          if ($allProjects.Count -eq 0) {
            Write-Host "##[warning]No packable projects found matching the patterns"
            Write-Host "##vso[task.setvariable variable=HasNewPackages]false"
            exit 0
          }
          
          Write-Host "Found $($allProjects.Count) project(s) to process"
          
          # 处理每个项目
          foreach ($project in $allProjects) {
            Write-Host ""
            Write-Host "=== Processing: $($project.Name) ==="
            
            # 读取项目版本
            [xml]$csproj = Get-Content $project.FullName
            $currentVersion = $csproj.Project.PropertyGroup.Version
            
            if ([string]::IsNullOrEmpty($currentVersion)) {
              $currentVersion = "1.0.0"
              Write-Host "##[warning]No version specified, using default: $currentVersion"
            }
            
            # 提取包名（移除 .csproj 扩展名）
            $packageName = $project.BaseName
            Write-Host "Package: $packageName"
            Write-Host "Version: $currentVersion"
            
            # 检查版本是否已存在
            Write-Host "Checking if version exists in feed..."
            $versionExists = $false
            
            try {
              # 使用 dotnet nuget 命令搜索包
              $searchCmd = "dotnet nuget list source $(artifactFeed) $packageName --format json"
              $searchResult = Invoke-Expression $searchCmd 2>&1 | Out-String
              
              # 检查是否包含当前版本
              if ($searchResult -match "$packageName\s+$currentVersion") {
                $versionExists = $true
              }
            } catch {
              Write-Host "##[warning]Could not search feed (this is OK for first-time packages)"
            }
            
            if ($versionExists) {
              Write-Host "##[warning]Version $currentVersion already exists in feed - SKIPPING"
            } else {
              Write-Host "##[section]Version $currentVersion is NEW - PACKING"
              
              # 打包项目
              $packResult = dotnet pack $project.FullName `
                --configuration $(buildConfiguration) `
                --no-build `
                --output $outputDir `
                /p:Version=$currentVersion
              
              if ($LASTEXITCODE -eq 0) {
                Write-Host "✓ Successfully packed $packageName $currentVersion"
                $hasNewPackages = $true
              } else {
                Write-Host "##[error]Failed to pack $packageName"
              }
            }
          }
          
          # 设置变量供后续步骤使用
          Write-Host ""
          Write-Host "=== Summary ==="
          if ($hasNewPackages) {
            Write-Host "##[section]New packages are ready to push"
            Write-Host "##vso[task.setvariable variable=HasNewPackages]true"
          } else {
            Write-Host "##[warning]No new packages to push"
            Write-Host "##vso[task.setvariable variable=HasNewPackages]false"
          }

    - task: NuGetCommand@2
      displayName: 'Push NuGet Packages to Azure Artifacts'
      condition: eq(variables['HasNewPackages'], 'true')
      inputs:
        command: 'push'
        packagesToPush: '$(Build.ArtifactStagingDirectory)/packages/*.nupkg'
        nuGetFeedType: 'internal'
        publishVstsFeed: '$(artifactFeed)'
        allowPackageConflicts: true

# ============================================
# Stage 4: 部署到开发环境
# ============================================
- stage: Deploy_Dev
  displayName: 'Deploy to Development IIS'
  dependsOn: 
  - Build
  - Test
  condition: and(succeeded(), eq(variables['Build.SourceBranchName'], 'develop'))
  variables:
    iisDeployPath: 'Projects/project1'
    aspnetEnvironment: 'Development'
    deployEnvironment: 'Development'
  jobs:
  - deployment: DeployToIIS
    displayName: 'Deploy to Development IIS Server'
    environment: $(deployEnvironment)
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: deployment-package
            displayName: 'Download Deployment Package'

          - task: PowerShell@2
            displayName: "Deploy to IIS (Development)"
            inputs:
              targetType: 'inline'
              script: |
                Import-Module WebAdministration

                $sitePath = "$(iisDeployPath)"
                $zipFile = "$(Pipeline.Workspace)/deployment-package/package.zip"
                $aspnetEnv = "$(aspnetEnvironment)"
                $tempExtractPath = "$(Agent.TempDirectory)/extracted"

                Write-Host "=== Starting IIS Deployment ==="
                Write-Host "Branch: $(Build.SourceBranchName)"
                Write-Host "Environment: $aspnetEnv"
                Write-Host "IIS Site Path: $sitePath"
                
                $site = Get-Item "IIS:\Sites\$sitePath"

                if (-not $site) {
                  Write-Host "##[error]Site '$sitePath' not found in IIS."
                  exit 1
                }

                $iisPath = $site.physicalPath
                $appPoolName = $site.applicationPool
                Write-Host "Target Path: $iisPath"
                Write-Host "App Pool: $appPoolName"

                # 清理旧文件夹
                if (Test-Path $tempExtractPath) { Remove-Item $tempExtractPath -Recurse -Force }
                New-Item -ItemType Directory -Path $tempExtractPath | Out-Null

                # 解压部署包
                Expand-Archive -Path $zipFile -DestinationPath $tempExtractPath -Force

                # 若解压后只有一层目录，进入那一层
                $items = Get-ChildItem $tempExtractPath
                if ($items.Count -eq 1 -and $items[0].PSIsContainer) {
                  $tempExtractPath = $items[0].FullName
                }

                # 停止 App Pool
                try {
                    $appPool = Get-WebAppPoolState -Name $appPoolName -ErrorAction SilentlyContinue
                    if ($appPool.Value -eq "Started") {
                        Write-Host "Stopping App Pool: $appPoolName"
                        Stop-WebAppPool -Name $appPoolName -ErrorAction Stop
                        Start-Sleep -Seconds 3
                    } else {
                        Write-Host "App Pool '$appPoolName' is already stopped. Skipping..."
                    }
                } catch {
                    Write-Host "##[warning]Could not stop App Pool '$appPoolName' — it may not exist."
                }

                # 部署文件
                Write-Host "Deploying files to: $iisPath"
                Copy-Item "$tempExtractPath\*" $iisPath -Recurse -Force

                # 设置 ASPNETCORE_ENVIRONMENT 环境变量到 App Pool
                Write-Host "Setting ASPNETCORE_ENVIRONMENT to: $aspnetEnv"
                try {
                    # 使用 appcmd 设置环境变量（最简单直接的方式）
                    $appcmd = "$env:SystemRoot\System32\inetsrv\appcmd.exe"
                    
                    # 设置环境变量
                    & $appcmd set config -section:system.applicationHost/applicationPools "/[name='$appPoolName'].environmentVariables.[name='ASPNETCORE_ENVIRONMENT'].value:$aspnetEnv" /commit:apphost
                    
                    if ($LASTEXITCODE -eq 0) {
                        Write-Host "✓ Environment variable set successfully: ASPNETCORE_ENVIRONMENT = $aspnetEnv"
                    } else {
                        Write-Host "##[warning]appcmd returned exit code $LASTEXITCODE"
                    }
                } catch {
                    Write-Host "##[error]Could not set environment variable: $_"
                    Write-Host "##[warning]Application will use default Production environment"
                }

                # 启动 App Pool
                Start-WebAppPool -Name $appPoolName
                Write-Host "✓ Deployment completed successfully"
                Write-Host "  - Site: $sitePath"
                Write-Host "  - Environment: $aspnetEnv"

# ============================================
# Stage 5: 部署到生产环境
# ============================================
- stage: Deploy_Prod
  displayName: 'Deploy to Production IIS'
  dependsOn: 
  - Build
  - Test
  condition: and(succeeded(), eq(variables['Build.SourceBranchName'], 'main'))
  variables:
    iisDeployPath: 'Prod/project1'
    aspnetEnvironment: 'Production'
    deployEnvironment: 'Production'
  jobs:
  - deployment: DeployToIIS
    displayName: 'Deploy to Production IIS Server'
    environment: $(deployEnvironment)
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: deployment-package
            displayName: 'Download Deployment Package'

          - task: PowerShell@2
            displayName: "Deploy to IIS (Production)"
            inputs:
              targetType: 'inline'
              script: |
                Import-Module WebAdministration

                $sitePath = "$(iisDeployPath)"
                $zipFile = "$(Pipeline.Workspace)/deployment-package/package.zip"
                $aspnetEnv = "$(aspnetEnvironment)"
                $tempExtractPath = "$(Agent.TempDirectory)/extracted"

                Write-Host "=== Starting IIS Deployment ==="
                Write-Host "Branch: $(Build.SourceBranchName)"
                Write-Host "Environment: $aspnetEnv"
                Write-Host "IIS Site Path: $sitePath"
                
                $site = Get-Item "IIS:\Sites\$sitePath"

                if (-not $site) {
                  Write-Host "##[error]Site '$sitePath' not found in IIS."
                  exit 1
                }

                $iisPath = $site.physicalPath
                $appPoolName = $site.applicationPool
                Write-Host "Target Path: $iisPath"
                Write-Host "App Pool: $appPoolName"

                # 清理旧文件夹
                if (Test-Path $tempExtractPath) { Remove-Item $tempExtractPath -Recurse -Force }
                New-Item -ItemType Directory -Path $tempExtractPath | Out-Null

                # 解压部署包
                Expand-Archive -Path $zipFile -DestinationPath $tempExtractPath -Force

                # 若解压后只有一层目录，进入那一层
                $items = Get-ChildItem $tempExtractPath
                if ($items.Count -eq 1 -and $items[0].PSIsContainer) {
                  $tempExtractPath = $items[0].FullName
                }

                # 停止 App Pool
                try {
                    $appPool = Get-WebAppPoolState -Name $appPoolName -ErrorAction SilentlyContinue
                    if ($appPool.Value -eq "Started") {
                        Write-Host "Stopping App Pool: $appPoolName"
                        Stop-WebAppPool -Name $appPoolName -ErrorAction Stop
                        Start-Sleep -Seconds 3
                    } else {
                        Write-Host "App Pool '$appPoolName' is already stopped. Skipping..."
                    }
                } catch {
                    Write-Host "##[warning]Could not stop App Pool '$appPoolName' — it may not exist."
                }

                # 部署文件
                Write-Host "Deploying files to: $iisPath"
                Copy-Item "$tempExtractPath\*" $iisPath -Recurse -Force

                # 设置 ASPNETCORE_ENVIRONMENT 环境变量到 App Pool
                Write-Host "Setting ASPNETCORE_ENVIRONMENT to: $aspnetEnv"
                try {
                    # 使用 appcmd 设置环境变量（最简单直接的方式）
                    $appcmd = "$env:SystemRoot\System32\inetsrv\appcmd.exe"
                    
                    # 设置环境变量
                    & $appcmd set config -section:system.applicationHost/applicationPools "/[name='$appPoolName'].environmentVariables.[name='ASPNETCORE_ENVIRONMENT'].value:$aspnetEnv" /commit:apphost
                    
                    if ($LASTEXITCODE -eq 0) {
                        Write-Host "✓ Environment variable set successfully: ASPNETCORE_ENVIRONMENT = $aspnetEnv"
                    } else {
                        Write-Host "##[warning]appcmd returned exit code $LASTEXITCODE"
                    }
                } catch {
                    Write-Host "##[error]Could not set environment variable: $_"
                    Write-Host "##[warning]Application will use default Production environment"
                }

                # 启动 App Pool
                Start-WebAppPool -Name $appPoolName
                Write-Host "✓ Deployment completed successfully"
                Write-Host "  - Site: $sitePath"
                Write-Host "  - Environment: $aspnetEnv"