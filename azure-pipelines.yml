trigger:
- main

pool:
  name: 'binet-window-agent'

variables:
  solution: '**/*.sln'
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'
  artifactFeed: 'binet25'
  packableProjects: |
    **/*.Entities.csproj
    **/*.Services.csproj

steps:
- task: DotNetCoreCLI@2
  displayName: 'Restore packages'
  inputs:
    command: 'restore'
    projects: '**/*.csproj'

- task: DotNetCoreCLI@2
  displayName: 'Build'
  inputs:
    command: 'build'
    projects: '**/*.csproj'
    arguments: '--configuration $(buildConfiguration) --no-restore'

# è¿è¡Œå•å…ƒæµ‹è¯•
- task: DotNetCoreCLI@2
  displayName: 'Run Unit Tests'
  inputs:
    command: 'test'
    projects: '**/*.UnitTest.csproj'
    arguments: '--configuration $(buildConfiguration) --no-build'
    publishTestResults: true

- task: PowerShell@2
  displayName: 'Check and Pack NuGet Packages'
  inputs:
    targetType: 'inline'
    script: |
      # å®šä¹‰è¦æ‰“åŒ…çš„é¡¹ç›®æ¨¡å¼
      $projectPatterns = "$(packableProjects)" -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne "" }
      
      $feedUrl = "https://pkgs.dev.azure.com/binet25/_packaging/$(artifactFeed)/nuget/v3/index.json"
      $outputDir = "$(Build.ArtifactStagingDirectory)/packages"
      $hasNewPackages = $false
      
      if (-not (Test-Path $outputDir)) {
        New-Item -ItemType Directory -Path $outputDir | Out-Null
      }
      
      Write-Host "=== Scanning for packable projects ==="
      
      $allProjects = @()
      foreach ($pattern in $projectPatterns) {
        $foundProjects = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter ($pattern -replace '\*\*/', '') -Recurse -ErrorAction SilentlyContinue
        $allProjects += $foundProjects
      }
      
      if ($allProjects.Count -eq 0) {
        Write-Host "##[warning]No packable projects found matching the patterns"
        Write-Host "##vso[task.setvariable variable=HasNewPackages]false"
        exit 0
      }
      
      Write-Host "Found $($allProjects.Count) project(s) to process"
      
      # å¤„ç†æ¯ä¸ªé¡¹ç›®
      foreach ($project in $allProjects) {
        Write-Host ""
        Write-Host "=== Processing: $($project.Name) ==="
        
        # è¯»å–é¡¹ç›®ç‰ˆæœ¬
        [xml]$csproj = Get-Content $project.FullName
        $currentVersion = $csproj.Project.PropertyGroup.Version
        
        if ([string]::IsNullOrEmpty($currentVersion)) {
          $currentVersion = "1.0.0"
          Write-Host "##[warning]No version specified, using default: $currentVersion"
        }
        
        # æå–åŒ…åï¼ˆç§»é™¤ .csproj æ‰©å±•åï¼‰
        $packageName = $project.BaseName
        Write-Host "Package: $packageName"
        Write-Host "Version: $currentVersion"
        
        # æ£€æŸ¥ç‰ˆæœ¬æ˜¯å¦å·²å­˜åœ¨
        Write-Host "Checking if version exists in feed..."
        $versionExists = $false
        
        try {
          # ä½¿ç”¨ dotnet nuget å‘½ä»¤æœç´¢åŒ…
          $searchCmd = "dotnet nuget list source $(artifactFeed) $packageName --format json"
          $searchResult = Invoke-Expression $searchCmd 2>&1 | Out-String
          
          # æ£€æŸ¥æ˜¯å¦åŒ…å«å½“å‰ç‰ˆæœ¬
          if ($searchResult -match "$packageName\s+$currentVersion") {
            $versionExists = $true
          }
        } catch {
          Write-Host "##[warning]Could not search feed (this is OK for first-time packages)"
        }
        
        if ($versionExists) {
          Write-Host "##[warning]Version $currentVersion already exists in feed - SKIPPING"
        } else {
          Write-Host "##[section]Version $currentVersion is NEW - PACKING"
          
          # æ‰“åŒ…é¡¹ç›®
          $packResult = dotnet pack $project.FullName `
            --configuration $(buildConfiguration) `
            --no-build `
            --output $outputDir `
            /p:Version=$currentVersion
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "âœ“ Successfully packed $packageName $currentVersion"
            $hasNewPackages = $true
          } else {
            Write-Host "##[error]Failed to pack $packageName"
          }
        }
      }
      
      # è®¾ç½®å˜é‡ä¾›åç»­æ­¥éª¤ä½¿ç”¨
      Write-Host ""
      Write-Host "=== Summary ==="
      if ($hasNewPackages) {
        Write-Host "##[section]New packages are ready to push"
        Write-Host "##vso[task.setvariable variable=HasNewPackages]true"
      } else {
        Write-Host "##[warning]No new packages to push"
        Write-Host "##vso[task.setvariable variable=HasNewPackages]false"
      }

# æ¨é€ NuGet åŒ…åˆ° Azure Artifacts
- task: NuGetCommand@2
  displayName: 'Push NuGet Packages to Azure Artifacts'
  condition: eq(variables['HasNewPackages'], 'true')
  inputs:
    command: 'push'
    packagesToPush: '$(Build.ArtifactStagingDirectory)/packages/*.nupkg'
    nuGetFeedType: 'internal'
    publishVstsFeed: '$(artifactFeed)'
    allowPackageConflicts: true

- task: DotNetCoreCLI@2
  displayName: 'Publish API Project'
  inputs:
    command: 'publish'
    projects: '**/*.API.csproj'
    arguments: '--configuration $(buildConfiguration) --no-build -o $(Build.ArtifactStagingDirectory)/publish'
    publishWebProjects: false
    zipAfterPublish: false

# æ‰“åŒ…å‘å¸ƒæ–‡ä»¶ç”¨äºéƒ¨ç½²
- task: ArchiveFiles@2
  displayName: 'Archive for Deployment'
  inputs:
    rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/publish'
    includeRootFolder: false
    archiveType: 'zip'
    archiveFile: '$(Build.ArtifactStagingDirectory)/package.zip'
    replaceExistingArchive: true

# å‘å¸ƒ NuGet åŒ…åˆ° Artifactsï¼ˆä»…åœ¨æœ‰æ–°åŒ…æ—¶ï¼‰
# - task: PublishBuildArtifacts@1
#   displayName: 'Publish NuGet Packages Artifact'
#   condition: eq(variables['HasNewPackages'], 'true')
#   inputs:
#     pathToPublish: '$(Build.ArtifactStagingDirectory)/packages'
#     artifactName: 'nuget-packages'

# éƒ¨ç½²åˆ° IIS
- task: PowerShell@2
  displayName: "Deploy to IIS (auto-detect)"
  inputs:
    targetType: 'inline'
    script: |
      Import-Module WebAdministration

      $sitePath = "Projects/project1"   # ğŸ‘‰ åªéœ€æ”¹è¿™é‡Œ
      $zipFile = "$(Build.ArtifactStagingDirectory)/package.zip"
      $tempExtractPath = "$(Build.ArtifactStagingDirectory)/extracted"

      Write-Host "=== Starting IIS Deployment to '$sitePath' ==="
      $site = Get-Item "IIS:\Sites\$sitePath"

      if (-not $site) {
        Write-Host "##[error]Site '$sitePath' not found in IIS."
        exit 1
      }

      $iisPath = $site.physicalPath
      $appPoolName = $site.applicationPool
      Write-Host "Target Path: $iisPath"
      Write-Host "App Pool: $appPoolName"

      # æ¸…ç†æ—§æ–‡ä»¶å¤¹
      if (Test-Path $tempExtractPath) { Remove-Item $tempExtractPath -Recurse -Force }
      New-Item -ItemType Directory -Path $tempExtractPath | Out-Null

      # è§£å‹éƒ¨ç½²åŒ…
      Expand-Archive -Path $zipFile -DestinationPath $tempExtractPath -Force

      # è‹¥è§£å‹ååªæœ‰ä¸€å±‚ç›®å½•ï¼Œè¿›å…¥é‚£ä¸€å±‚
      $items = Get-ChildItem $tempExtractPath
      if ($items.Count -eq 1 -and $items[0].PSIsContainer) {
        $tempExtractPath = $items[0].FullName
      }

      # åœæ­¢ App Pool
      Write-Host "Stopping App Pool: $appPoolName"
      Stop-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue
      Start-Sleep -Seconds 5

      # éƒ¨ç½²æ–‡ä»¶
      Write-Host "Deploying files to: $iisPath"
      Copy-Item "$tempExtractPath\*" $iisPath -Recurse -Force

      # å¯åŠ¨ App Pool
      Start-WebAppPool -Name $appPoolName
      Write-Host "âœ“ Deployment completed successfully to $sitePath"